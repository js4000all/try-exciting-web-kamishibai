# 目的

このリポジトリは、**HTML 1 ファイルで動く最小構成の紙芝居ノベルエンジン**です。
シナリオ（台本）をコマンド配列として記述し、クリックで進行・条件分岐・選択肢遷移を行います。

README は、次の 3 つの読者を想定して構成しています。

1. **エンドユーザー（遊ぶ人）**: まず動かして体験するための手順
2. **エンジン使用者（ゲーム開発者）**: 台本を作る・改変するための仕様
3. **エンジン開発者 / AI エージェント**: 実装拡張時の責務分離と開発ルール

---

# 1. エンドユーザー向け（遊ぶ人）

## 1-1. すぐに動かす

ES Modules を使っているため、`file://` で直接開かず **ローカルサーバー経由**で起動してください。

```bash
cd static
python -m http.server 8000
# ブラウザで http://127.0.0.1:8000/index.html を開く
```

## 1-2. 遊び方

- 画面クリックで次の台詞へ進みます。
- 選択肢が表示されたら、選んだ項目によって分岐します。
- 進行はシナリオの `jump` / `jumpIf` / `choice` に従って制御されます。

## 1-3. うまく動かないとき

- 画面が真っ白: `file://` で開いていないか確認してください。
- 起動時にエラー: シナリオ検証（`validateScript`）で不正が検出された可能性があります。コンソールを確認してください。

---

# 2. エンジン使用者向け（ゲーム開発者）

## 2-1. ディレクトリ構成

```text
.
├── README.md
├── LICENSE
└── static/
    ├── index.html                    # renderer + 初期化
    └── js/
        ├── engine/
        │   ├── parseScenario.js      # DSL -> 内部シナリオモデル変換
        │   ├── runtime.js            # 進行制御（内部モデルを実行）
        │   └── validateScript.js     # 台本検証
        └── scenarios/sample.js       # 台本データ
```

## 2-2. 台本の基本

`script` 配列の 1 要素が 1 コマンドです。
`createRuntime` 初期化時に `validateScript` で台本を検証し、`parseScenarioScript` で内部シナリオモデルへ変換してから実行します。これにより将来 DSL 形式が変わっても、ランタイムは内部モデルを維持したまま差し替えできます。

### コマンドキー（必須 / 任意）

| コマンド | 必須キー | 任意キー | 説明 |
| --- | --- | --- | --- |
| `label` | `label: string` | - | ジャンプ先の目印を定義（表示はしない）。 |
| 発話 | - | `name: string`, `text: string` | 発話者名と本文を表示。 |
| 背景 | - | `bg: string`, `bgColor: string` | 背景画像 URL または CSS 背景指定を更新。 |
| 立ち絵 | - | `leftOn: boolean`, `rightOn: boolean`, `left: string`, `right: string` | 左右キャラクターの表示/画像を更新。 |
| フラグ更新 | - | `set: Record<string, any>` | 状態フラグを更新。 |
| `jump` | `jump: string` | - | 指定 `label` へジャンプ。 |
| `jumpIf` | `jumpIf.key`, `jumpIf.equals`, `jumpIf.to` | - | 条件成立時のみ `to` の `label` へジャンプ。 |
| `choice` | `choice: Array<Choice>` | - | 選択肢を表示。 |
| `Choice` | `text: string` | `set?: object`, `jump?: string` | 選択時に状態更新・ジャンプ。 |

### 検証でチェックされる項目

- `label` の重複（どの index と重複したかも表示）
- `jump` / `jumpIf.to` / `choice[].jump` の未定義ラベル参照
- `choice` が配列形式であること
- `choice[].text` が必須で、空でない文字列であること

### 検証エラーの読み方

検証エラーには配列 index が `[...]` 形式で付きます。例:

```text
スクリプト検証エラー:
[5] choice は配列で指定してください。
[9] jumpIf.to ラベル "ending" が未定義です。
```

- `[5]` は `script[5]` のコマンドが不正という意味です。
- 修正後に再読み込みすると、`createRuntime` が再検証して起動します。

## 2-3. 最小サンプル

```js
{ label: "start" }

{ choice: [
    { text: "話しかける", set: { flag_talk: true }, jump: "talk" },
    { text: "無視する", set: { flag_talk: false }, jump: "ignore" },
  ]
}

{ label: "talk" }
{ jumpIf: { key: "flag_talk", equals: true, to: "end" } }

{ label: "ignore" }

{ set: { flag_talk: false } }
{ jump: "end" }
```

このサンプルで `label / jump / jumpIf / choice / set` の基本的な使い方を確認できます。

---

# 3. エンジン開発者 / AI エージェント向け

## 3-1. 設計原則（責務分離）

機能追加時は、以下の責務分離を必ず守ってください。

- `scenario`（データ）: 台本そのもの。命令データのみを持ち、描画ロジックを直接書かない。
- `parseScenario`（パーサ）: DSL を内部シナリオモデルへ正規化する。
- `runtime`（進行制御）: 内部モデルを実行し、状態遷移・分岐・ジャンプを制御する。
- `renderer`（描画）: 実行結果を DOM にどう反映するか（背景・立ち絵・テキスト・選択肢 UI）。

> 原則: 「進行制御」と「描画」と「データ」を混ぜない。将来的にファイル分割する場合もこの境界を維持すること。

## 3-2. 変更時チェックリスト

### 新規コマンドを追加する場合

- [ ] コマンドのスキーマを定義・追記する（README の「コマンド仕様」を更新）。
- [ ] `runtime` に実行ルールを実装する（状態更新・分岐・停止条件を明確化）。
- [ ] 必要なら `renderer` の反映処理を実装する（見た目変更がある場合）。
- [ ] README に利用例（最小サンプル）を追記する。
- [ ] 既存シナリオで互換性確認を行う。

### AI エージェントが作業する場合の推奨手順

- [ ] 変更前に README と `static/js/engine/*.js` の責務境界を確認する。
- [ ] 仕様変更がある場合は、実装より先に README の該当箇所を更新する。
- [ ] 参照先ラベル・`choice` 形式など、`validateScript` が担保する前提を崩さない。
- [ ] 目視確認時はローカルサーバー経由で起動し、最低 1 つの分岐を最後まで辿る。

## 3-3. 保守の観点

- **後方互換性重視**: 既存シナリオのコマンドを壊さない。
- **失敗の早期検出**: 実行時に壊れるより、検証時に落とす。
- **データ駆動維持**: 台本データにロジックを混ぜず、エンジン側で解釈する。
